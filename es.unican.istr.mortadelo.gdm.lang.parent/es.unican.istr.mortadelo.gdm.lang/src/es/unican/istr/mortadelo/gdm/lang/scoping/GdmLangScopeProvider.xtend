/*
 * generated by Xtext 2.13.0
 */
package es.unican.istr.mortadelo.gdm.lang.scoping

import es.unican.istr.mortadelo.gdm.lang.gdmLang.Alias
import es.unican.istr.mortadelo.gdm.lang.gdmLang.Attribute
import es.unican.istr.mortadelo.gdm.lang.gdmLang.AttributeSelection
import es.unican.istr.mortadelo.gdm.lang.gdmLang.BooleanExpression
import es.unican.istr.mortadelo.gdm.lang.gdmLang.Entity
import es.unican.istr.mortadelo.gdm.lang.gdmLang.From
import es.unican.istr.mortadelo.gdm.lang.gdmLang.GdmLangPackage
import es.unican.istr.mortadelo.gdm.lang.gdmLang.Inclusion
import es.unican.istr.mortadelo.gdm.lang.gdmLang.Model
import es.unican.istr.mortadelo.gdm.lang.gdmLang.Query
import es.unican.istr.mortadelo.gdm.lang.gdmLang.Reference
import java.util.ArrayList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class GdmLangScopeProvider extends AbstractGdmLangScopeProvider {
  override getScope(EObject context, EReference reference) {
    if (context instanceof AttributeSelection) {
      if (reference == GdmLangPackage.Literals.ATTRIBUTE_SELECTION__REF_ALIAS) {
        val query = getQueryFromContainer(context.eContainer)
        val aliases = new ArrayList<Alias>
        if (query.from !== null && query.from.alias !== null) {
          aliases.add(query.from.alias)
        }
        aliases.addAll(query.inclusions.filter(j | j.alias !== null)
                                       .map[j | j.alias])
        return Scopes.scopeFor(aliases)
      } else if (reference == GdmLangPackage.Literals.ATTRIBUTE_SELECTION__ATTRIBUTE) {
        if ((context as AttributeSelection).refAlias !== null) {
          var Entity entity = getEntity((context as AttributeSelection).refAlias)
          if (entity !== null) {
            var attributes = entity.features.filter[f | f instanceof Attribute]
            return Scopes.scopeFor(attributes)
          }
        }
      }
    }
    if (context instanceof Inclusion) {
      if (reference == GdmLangPackage.Literals.INCLUSION__REF_ALIAS) {
        val query = context.eContainer as Query
        val aliases = new ArrayList<Alias>
        if (query.from !== null && query.from.alias !== null) {
          aliases.add(query.from.alias)
        }
        aliases.addAll(query.inclusions.filter(j | j.alias !== null)
                                       .map[j | j.alias])
        return Scopes.scopeFor(aliases)
      } else if (reference == GdmLangPackage.Literals.INCLUSION__REFS
            && (context as Inclusion).refAlias !== null) {
        // All refs in the model as scope: this allows wrong reference chains
        //TODO: check the chain is correct in the validator (easier)
        val model = EcoreUtil.getRootContainer(context) as Model
        val references = model.eAllContents
                              .filter(elem | elem instanceof Reference)
                              .map(elem | elem as Reference).toIterable
        return Scopes.scopeFor(references)
      }
    }
    return super.getScope(context, reference);
  }
  
  def Query getQueryFromContainer(EObject container) {
    if (container instanceof Query) {
      return container as Query
    } else if (container instanceof BooleanExpression) {
      var EObject node = container
      while (!(node instanceof Query)) {
        node = node.eContainer
      }
      return node as Query
    }
  }

  def Entity getEntity(Alias alias) {
    if (alias === null) {
      return null
    }
    val container = alias.eContainer
    if (container instanceof From) {
        return (container as From).entity
    } else if (container instanceof Inclusion) {
      return (container as Inclusion).refs.last.entity
    }
  }
}
